---
title: 字符串小纪
tags: ['整理', '算法', '字符串']
---

## 一些约定

- 文中所有字符串字面量均用打字机字体表示，如 $\texttt{abc}$。
- 字符串从 $0$ 开始标号。
- 设 $s$ 为一个字符串，$s_{l\dots r}$ 表示第 $l$ 个字符到第 $r$ 个字符的子串。
- ${\rm LCP}(a,b)$ 当 $a$ 和 $b$ 是两个字符串时表示这两个字符串的最长公共前缀长度，是两个数字时表示对于上下文中的字符串 $s$ 和长度 $n$ 求出的 ${\rm LCP}(s_{a\dots n},s_{b\dots n})$。

## 前缀函数，Border 与周期

### 定义、求法

对于一个特定的字符串 $s$，其中 $|s|=n$。其前缀函数 $\pi(i)$ 是定义在下标上的一个函数，$\pi(i)$ 表示使得 $s_{1\dots x}=s_{i-x+1\dots i}$ 且 $x<i$ 的最大的 $x$。

定义字符串 $s$ 的 Border 集合 ${\rm B}(i)$ 表示 $\set{x\in\N|s_{1\dots x}=s_{i-x+1,i},x<i}$。显然 ${\rm B}(i)={\rm B}(\pi(i))\cup\set{\pi(i)}$。

定义字符串 $s$ 的周期集合 $\rm S$ 表示 $\set{x\in\N|1\leq x\leq n,\forall1\leq i\leq n-i+1,s_i=s_{i+x}}$。显然，${\rm S}=\set{n-x|x\in{\rm Bd}(n)}$。定义整周期集合 ${\rm T}$ 表示 $\set{x\in{\rm S}:x|n}$

$\pi(i)$ 可以通过 KMP 在 $\mathcal O(n)$ 的时间内求出。

### 性质

**弱周期引理 Weak Periodicity Lemma** 对于 $x,y\in{\rm S}$，如果 $x+y\leq n$，那么 $\gcd(x,y)\in{\rm S}$。

首先 $x=y$ 的情况显然；否则钦定 $x>y$，那么 $\forall x<i\leq x+y$，有 $s_i=s_{i-x}=s_{i-y}$，那么也就是说 $\forall 1\leq i\leq x$，有 $s_{i}=s_{i-(x-y)}$，也就是 $x-y$ 是 $s_{1\dots x}$ 的一个周期。而对于 $i>x$，有 $s_i=s_{i-x}=s_{i-(x-y)}$，因此有 $x-y\in{\rm S}$。应用辗转相除法，得到 $\gcd(x,y)\in{\rm S}$。

**周期引理 Periodicity Lemma** 对于 $x,y\in S$，如果 $x+y-\gcd(x,y)\leq n$，那么 $\gcd(x,y)\in{\rm S}$。

不会证。

根据弱周期引理，如果一个字符串存在整周期，那么其最小周期一定是整周期。

**短周期结构** 设 $d=\min{\rm S}$，对于所有 $x\in{\rm S}$ 且 $x\leq\frac{n}{2}$，有 $d\mid x$。

如果 $d\not\mid x$，那么有 $d+x\leq n$，所以 $\gcd(d,x)\in{\rm S}$。显然 $\gcd(d,x)<d$，因此 $d\neq\min{\rm S}$。矛盾。

结合周期的定义，不难得到，如果 $d\in{\rm S}$，那么所有不超过 $n$ 的 $d$ 的倍数也属于 ${\rm S}$。据此，可以得知：**字符串 $s$ 的所有长度不超过 $\frac{n}{2}$ 的周期构成一个等差数列，并且所有数都是数列中最小数的倍数；反过来说，所有长度至少为 $\frac{n}{2}$ 的 Border 构成一个等差数列，并且向后扩展一位是 $n$。**

也就是说，可以把 $s$ 的所有 Border 划分成 $\mathcal O(\log n)$ 个值域不交的等差数列。

## Z 函数

### 定义、求法

对于字符串 $s$，$|s|=n$，其 Z 函数 $z(i)$ 是定义在下标上的一个函数，$z(i)$ 表示 ${\rm LCP}(s,s_{i\dots n})$。规定 $z(1)=0$。

求 Z 函数可以按照下标从左往右求。求 $z(i)$ 的时候维护一个值 $r$ 表示 $\max_{j<i}\set{j+z(j)-1}$ 以及此时的 $j$ 记为 $l$，如果 $i\leq r$，那么 $z(i)$ 至少是 $\min\set{z(i-l+1),r-i+1}$，从这个值开始暴力扩展；否则就直接暴力计算。复杂度是 $\mathcal O(n)$ 的。

### 用途

1. 用于求模式串在文本串中的所有匹配：只要对 模式串 + 文本串 求 Z 函数，然后在文本串部分枚举匹配的第一个字符判断能否构成匹配即可。

2. 在 $\mathcal O(n^2)$ 时间内计算一个字符串 $s$（$|s|=n$）的本质不同子串数量：

   先从前往后枚举子串的起点，计算从这个子串开始在前面没出现过的子串的数量。发现合法的子串一定是长度大于某个值的子串的数量。设 $z_i$ 表示 $s_{i\dots n}$ 的 Z 函数，那么对于第 $i$ 个位置而言，贡献就是 $n-\max_{j<i}\set{j+z_j(i)}$。

## Manacher 算法

### 定义、求法

对于字符串 $s$，定义 $p(i)$ 表示最大的整数 $x$ 使得 $\forall 0\leq i<x,p_{i+x}=p_{i-x}$，即最大回文半径。$p_0=0$。

求法和求 Z 函数类似，求 $p(i)$ 时先维护一个 $r$ 表示 $\max_{j<i}\set{j+p(j)-1}$，以及此时的 $j$ 记为 $k$。如果 $i\leq r$，那么 $p(i)$ 至少为 $\min\set{p(2k-i),r-i+1}$，暴力扩展；否则就从 $1$ 开始暴力扩展。复杂度也是 $\mathcal O(n)$ 的。

### 用途、性质

1. 求字符串的最长回文子串。为了同时考虑长度为偶数的回文串，可以在原串中两个字符和首位插入一个相同的特殊字符，然后求出 $p$，答案就是 $\max\set{p(i)}-1$。
2. 一个字符串的本质不同回文子串个数是 $\mathcal O(n)$ 的。

## 后缀数组

### 定义、求法

对于字符串 $s$，$|s|=n$，定义 ${\rm sa}(i)$ 表示将 $s$ 的所有后缀排序之后第 $i$ 小的后缀的第一个字符的下标。

类似地定义一个 ${\rm rk}(i)$ 表示将 $s$ 的所有后缀排序之后 $s_{i\dots n}$ 的排名。

使用倍增在 $\mathcal O(n\log n)$ 的时间复杂度内求出 $\rm sa$ 和 $\rm rk$：

在倍增的过程中维护 ${\rm rk}_t$ 和 ${\rm sa}_t$ 表示只对每个后缀前 $2^t$ 个字符（不足用一个极小字符代替）排序的结果（如果有多种结果，那么任意一种都可以），${\rm rk}_0$ 和 ${\rm sa}_0$ 可以在 $\mathcal O(n)$ 的时间复杂度内求出。

假设已经求出 ${\rm rk}_t$ 和 ${\rm sa}_t$，需要求出 ${\rm rk}_{t+1}$ 和 ${\rm sa}_{t+1}$。

现在已经对每个后缀的前 $2^t$ 个字符进行了排序，那么可以把所有后缀的前 $2^t$ 个字符缩成一个字符，满足这些字符排序和前 $2^t$ 个字符排序的结果是一样的。经过这样的操作，排序结果是等价的。

现在要加入后 $2^t$ 个字符。后 $2^t$ 个字符的排名也已经知道了，所以也可以缩成一个字符，这样就可以用一个二元组来代替一个后缀，加入这 $2^t$ 个字符的影响实际上就是对这些二元组排序。

现在这些二元组已经按照第一项排好序了，只需要把第二项合并进来即可。这部分用基数排序，是 $\mathcal O(n)$ 的。

因此总复杂度是 $\mathcal O(n\log n)$ 的。

定义 height 数组 $h(i)$ 表示 ${\rm LCP}({\rm sa}(i),{\rm sa}(i-1))$，$h(1)=0$。

有定理：$h({\rm rk}(i))\geq h({\rm rk}(i-1))-1$。

证明：首先 LCP 有一个性质：对于一个特定的 $i$，在所有的 $j<i$ 中，${\rm LCP}({\rm sa}(j),{\rm sa}(i))$ 最大的一定是 $i-1$。

当 $h({\rm rk}(i-1))=0$ 的时候，显然成立；而当 $h({\rm rk}(i-1))>0$ 时，把 $s_{i-1\dots n}$ 和 $s_{{\rm sa}({\rm rk}(i-1)-1)\dots n}$ 去掉头部的一个字母，就得到了 $s_{i\dots n}$ 和另一个后缀的 LCP 为 $h({\rm rk}(i-1))-1$，也就证明了 $h({\rm rk}(i))\geq h({\rm rk}(i-1))-1$。

根据这个定理，就可以在 $\mathcal O(n)$ 的时间内求出 $h$。

### 性质

${\rm LCP}({\rm sa}(i),{\rm sa}(j))=\min_{i+1\leq k\leq j}\set{h(k)}$（这个性质对于任意一组有序的字符串都成立；放到字典树上可以直观地理解）

这点表明后缀数组搭配 height 数组实际上是 Z 函数的扩展。

把 $s$ 的所有后缀都放到字典树上，那么 ${\rm sa}$ 数组就相当于对这个字典树进行先序遍历的结果。

按照 ${\rm sa}$ 数组的顺序从小到大插入后缀，那么每次插入的后缀一定构成字典树的一个右链。

而 $h(i)$ 则表示的是，插入到 ${\rm sa}(i)$ 时，这条右链上最深的度数至少为 $2$ 或作为一个字符串结尾（除了 $s_{{\rm sa}(i)\dots n}$）的节点的深度（根节点深度为 $0$）。

### 用途

#### 求一个字符串本质不同子串数量

与 Z 函数求一个字符串本质不同子串数量的思想类似。

现在换一下枚举的顺序，按照 ${\rm sa}$ 数组的顺序枚举后缀，然后对每个后缀统计还没有出现过的子串数量。对于第 ${\rm sa}(i)$ 而言，这个子串数量是 $n-{\rm sa}(i)+1-h(i)$，求和也就是 $\frac{n(n+1)}{2}-\sum h(i)$。

#### 求一个字符串出现至少 $k$ 次的子串的数量

把 $s$ 中所有后缀放到字典树上，那么实际要求的就是被至少 $k$ 个后缀包含的节点数量 $-1$（去除空串）。

按照 ${\rm sa}$ 数组的顺序插入后缀，维护这条右链上每个节点被覆盖到的次数。具体实现的时候可以使用单调队列解决。
